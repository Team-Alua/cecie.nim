import "libjbc"
import "orbis/kernel"
import strutils
import endians
import posix
{.push stackTrace:off.}
proc kernelRdmsr(register: uint32) : uint64 {.cdecl,exportc.} =
  asm """
    ".intel_syntax;"
    "mov ecx, edi;"
    "rdmsr;"
    "shl rdx, 32;"
    "or rax, rdx;"
    : "=a"(`result`) """

#kernelRdmsr:
#        mov     ecx, edi
#        rdmsr
#        shl     rdx, 32
#        or      rax, rdx
#        ret

proc cpu_enable_wp() {.cdecl, exportc.} =
  asm """
    ".intel_syntax;"
    "mov rax, cr0;"
    "or rax, 0x10000;"
    "mov cr0, rax;"
  """
#cpu_enable_wp:
#    mov rax, cr0
#    or rax, 0x10000
#    mov cr0, rax
#    ret
proc cpu_disable_wp() {.cdecl, exportc.} =
  asm """
    ".intel_syntax;"
    "mov rax, cr0;"
    "and rax, ~0x10000;"
    "mov cr0, rax;"
  """

#cpu_disable_wp:
#  mov rax, cr0
#  and rax, ~0x10000
#  mov cr0, rax
#  ret
proc sys_fork(): cint {.cdecl, exportc.} =
  asm """
    ".intel_syntax;"
    "mov rax, 2;"
    "syscall;"
    : "=a"(`result`)
  """
proc sys_setsid(): cint {.cdecl, exportc.} =
  asm """
    ".intel_syntax;"
    "mov rax, 147;"
    "syscall;"
    : "=a"(`result`)
  """
{.pop.}


type SysEnt {.bycopy.} = object
  us1: array[8, byte]
  sy_call: uint64
  us2: array[32, byte]    

type SysEntTable = array[0x2A6, SysEnt]

type SysEntVec {.bycopy.} = object
  sv_size: cint
  padding: array[4, byte]
  sv_table: ptr SysEntTable


var gKernelBase: uint64

kexec:
  gKernelBase = kernelRdmsr(uint32(0xC0_00_00_82)) - 0x1C0

var se_table : SysEntTable 

var sys_ent_vec : SysEntVec

kexec:
  sysent_vec = cast[ptr SysEntVec](uint64(gKernelBase + 0x01528E30))[]
  for idx in countup(uint16(0), uint16(0x2A5)):
   se_table[idx].sy_call = sysent_vec.sv_table[][idx].sy_call
#echo "SysEntVec"
#echo "size:", sys_ent_vec.sv_size
#echo "Offset:",(cast [uint64](sys_ent_vec.sv_table) - gKernelBase).toHex(16)
#for idx in countup(uint16(0), uint16(0x2A5)):
#  echo "syscall ", idx, "@0x", (se_table[idx].sy_call - gKernelBase).toHex(16)


var cred = get_cred()
## Make a system process
cred.sonyCred = cred.sonyCred or uint64(1 shl 0x3E)
discard set_cred(cred)

var td = get_td()
#kexec:
#  cpu_disable_wp()
#  var patch1  : ptr array[64, uint8] = cast[ptr array[64, uint8]](gKernelBase + 0x000e9d7d'u64)
#  patch1[][0] = 0x31
#  patch1[][1] = 0xC0
#  patch1[][2] = 0x90
#  patch1[][3] = 0x90
#  patch1[][4] = 0x90
#  var patch2  : ptr array[64, uint8] = cast[ptr array[64, uint8]](gKernelBase + 0x000e9daf'u64)
#  patch2[][0] = 0x31
#  patch2[][1] = 0xC0
#  patch2[][2] = 0x90
#  patch2[][3] = 0x90
#  patch2[][4] = 0x90
#  var patch3  : ptr array[64, uint8] = cast[ptr array[64, uint8]](gKernelBase + 0x000e9e24'u64)
#  patch3[][0] = 0xBE
#  patch3[][1] = 0x9C
#  patch3[][2] = 0xFF
#  patch3[][3] = 0xFF
#  patch3[][4] = 0xFF
#
#  cpu_enable_wp()

var ucred = get_ucred()
var uid: uint32
var proccnt: uint64
kexec:
  proccnt = cast[ptr uint64](cast[uint64](ucred.cr_ruidinfo) + 0x40)[]
  uid = cast[ptr uint32](cast[uint64](ucred.cr_ruidinfo) + 0x50)[]
echo "uid:", uid.toHex(8)
echo "before proccnt:", proccnt.toHex(16)
var pid = sys_fork()

if pid != 0:
  kexec:
    var p : ptr uint64 = cast[ptr uint64](cast[uint64](ucred.cr_ruidinfo) + 0x40)
    p[] = p[] - 1'u64
    proccnt = p[]
  echo "after proccnt:", proccnt.toHex(16)

if pid == 0:
  echo "In child process ", getpid()
else:
  echo "In parent process ", getpid()
var appInfo: OrbisAppInfo
discard sceKernelGetAppInfo(getpid(),addr(appInfo))
echo "AppId:", appInfo.AppId
if pid == 0:

  var sp = sys_setsid()
  echo "setsid() = ",sp  
  if sp == -1:
    echo "errno = ", errno
  for i in 0..1:
    echo "Child process loop: ", i
    discard sleep(1)
  echo "Child process will exit now"
  exitnow(0)
#let pid = vfork()
#echo "pid1:", pid
#if pid < 0:
#  echo "Failed ", errno
#elif pid == 0:
#  echo "Called in child process"
#else:
#  echo "Called in parent process"
#
#if parent_pid == getpid():
#  echo "I am parent"
#else:
#  echo "I am child"

#let pid2 = vfork()
#echo "pid2:", pid
#echo "pid3:", getpid()
#exitnow(0)
#echo "Auth Id:", toBig(ucred.cr_sceAuthID).toHex(16)
#for idx, caps in ucred.cr_sceCaps:
#  echo "cred[", idx, "] = ", toBig(caps).toHex(16)
##  echo "authinfo.add(\"", toBig(caps).toHex(16), "\""
#for idx, attr in ucred.cr_sceAttr:
#  echo "attr[", idx, "] = ", toBig(attr).toHex(16)
##  echo "authinfo.add(\"", toBig(attr).toHex(16), "\""

#var cred = get_cred()
#echo "Auth Id:", toBig(cred.sceProcType).toHex(16)
#echo "cred or'd:", toBig(cred.sonyCred).toHex(16)
#echo "cap:", toBig(cred.sceProcCap).toHex(16)
# var fhd: array[100,Elf64_Phdr]
# var phdrSize: uint16 = uint16(sizeof(Elf64_Phdr))
# var phStart = gKernelBase + hdr.e_phoff
# echo "phStart:", (phStart).toHex(16)," off: ",  hdr.e_phoff.toHex(16) , " " , hdr.e_phnum.toHex(16)
# kexec:
#   for idx in countup(uint16(0), hdr.e_phnum):
#     if idx > 50:
#       break
#     let phdrOff = phStart + uint64(idx * phdrSize)
#     fhd[idx] = cast[ptr Elf64_Phdr](phdrOff)[]
# 
# for idx, fh in fhd:
#   if uint16(idx) == hdr.e_phnum:
#     break
#   let phdrOff = phStart + uint64(uint16(idx) * phdrSize)
#   echo "phHeader: ", (phdrOff).toHex(16), " type: ", fh.p_type.toHex(8), " flags:", $fh.p_flags.toHex(8)
#   if fh.p_flags == (PF_R or PF_X):
#     echo "rx => vaddr: ", fh.p_vaddr.toHex(16) , " memsz:" , fh.p_memsz.toHex(16)
#   elif fh.p_flags == (PF_R or PF_W):
#     echo "rw => vaddr: ", fh.p_vaddr.toHex(16) , " memsz:" , fh.p_memsz.toHex(16)
#
echo "Done!"
while true:
  discard
